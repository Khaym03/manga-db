// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package mangadb

import (
	"context"
)

const filterMangaByGenre = `-- name: FilterMangaByGenre :many
SELECT
    m.manga_id,
    m.title,
    m.subtitle,
    m.score,
    m.status
FROM
    Manga m
JOIN MangaGenre mg ON m.manga_id = mg.manga_id
JOIN Genre g ON mg.genre_id = g.genre_id
WHERE
    g.genre_name = ?
ORDER BY m.title
LIMIT ?
`

type FilterMangaByGenreParams struct {
	GenreName string `json:"genre_name"`
	Limit     int64  `json:"limit"`
}

type FilterMangaByGenreRow struct {
	MangaID  int64   `json:"manga_id"`
	Title    string  `json:"title"`
	Subtitle *string `json:"subtitle"`
	Score    float64 `json:"score"`
	Status   string  `json:"status"`
}

// Example Query: Filter Manga by Genre
func (q *Queries) FilterMangaByGenre(ctx context.Context, arg FilterMangaByGenreParams) ([]FilterMangaByGenreRow, error) {
	rows, err := q.db.QueryContext(ctx, filterMangaByGenre, arg.GenreName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterMangaByGenreRow
	for rows.Next() {
		var i FilterMangaByGenreRow
		if err := rows.Scan(
			&i.MangaID,
			&i.Title,
			&i.Subtitle,
			&i.Score,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMangaDetails = `-- name: GetAllMangaDetails :many
SELECT
    m.manga_id,
    m.title,
    m.subtitle,
    m.synopsis,
    m.score,
    m.members,
    m.cover_image_path,
    m.publication_year,
    m.type,
    m.status,
    m.total_volumes,
    m.total_chapters,
    COALESCE(genres_agg.genre_names, '') AS genres,
    COALESCE(authors_agg.author_names, '') AS authors,
    COALESCE(serializations_agg.serialization_names, '') AS serializations,
    COALESCE(demographics_agg.demographic_names, '') AS demographics,
    COALESCE(themes_agg.theme_names, '') AS themes
FROM
    Manga m
LEFT JOIN (
    SELECT
        mg.manga_id,
        GROUP_CONCAT(DISTINCT g.genre_name) AS genre_names
    FROM
        MangaGenre mg
    JOIN
        Genre g ON mg.genre_id = g.genre_id
    GROUP BY
        mg.manga_id
) AS genres_agg ON m.manga_id = genres_agg.manga_id
LEFT JOIN (
    SELECT
        ma.manga_id,
        GROUP_CONCAT(DISTINCT a.author_name) AS author_names
    FROM
        MangaAuthor ma
    JOIN
        Author a ON ma.author_id = a.author_id
    GROUP BY
        ma.manga_id
) AS authors_agg ON m.manga_id = authors_agg.manga_id
LEFT JOIN (
    SELECT
        ms.manga_id,
        GROUP_CONCAT(DISTINCT s.serialization_name) AS serialization_names
    FROM
        MangaSerialization ms
    JOIN
        Serialization s ON ms.serialization_id = s.serialization_id
    GROUP BY
        ms.manga_id
) AS serializations_agg ON m.manga_id = serializations_agg.manga_id
LEFT JOIN (
    SELECT
        md.manga_id,
        GROUP_CONCAT(DISTINCT d.demographic_name) AS demographic_names
    FROM
        MangaDemographic md
    JOIN
        Demographic d ON md.demographic_id = d.demographic_id
    GROUP BY
        md.manga_id
) AS demographics_agg ON m.manga_id = demographics_agg.manga_id
LEFT JOIN (
    SELECT
        mt.manga_id,
        GROUP_CONCAT(DISTINCT t.theme_name) AS theme_names
    FROM
        MangaTheme mt
    JOIN
        Theme t ON mt.theme_id = t.theme_id
    GROUP BY
        mt.manga_id
) AS themes_agg ON m.manga_id = themes_agg.manga_id
ORDER BY m.title
`

type GetAllMangaDetailsRow struct {
	MangaID         int64   `json:"manga_id"`
	Title           string  `json:"title"`
	Subtitle        *string `json:"subtitle"`
	Synopsis        string  `json:"synopsis"`
	Score           float64 `json:"score"`
	Members         int64   `json:"members"`
	CoverImagePath  string  `json:"cover_image_path"`
	PublicationYear int64   `json:"publication_year"`
	Type            string  `json:"type"`
	Status          string  `json:"status"`
	TotalVolumes    *int64  `json:"total_volumes"`
	TotalChapters   *int64  `json:"total_chapters"`
	Genres          string  `json:"genres"`
	Authors         string  `json:"authors"`
	Serializations  string  `json:"serializations"`
	Demographics    string  `json:"demographics"`
	Themes          string  `json:"themes"`
}

func (q *Queries) GetAllMangaDetails(ctx context.Context) ([]GetAllMangaDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllMangaDetails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllMangaDetailsRow
	for rows.Next() {
		var i GetAllMangaDetailsRow
		if err := rows.Scan(
			&i.MangaID,
			&i.Title,
			&i.Subtitle,
			&i.Synopsis,
			&i.Score,
			&i.Members,
			&i.CoverImagePath,
			&i.PublicationYear,
			&i.Type,
			&i.Status,
			&i.TotalVolumes,
			&i.TotalChapters,
			&i.Genres,
			&i.Authors,
			&i.Serializations,
			&i.Demographics,
			&i.Themes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthorByName = `-- name: GetAuthorByName :one
SELECT author_id FROM Author WHERE author_name = ?
`

func (q *Queries) GetAuthorByName(ctx context.Context, authorName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAuthorByName, authorName)
	var author_id int64
	err := row.Scan(&author_id)
	return author_id, err
}

const getDemographicByName = `-- name: GetDemographicByName :one
SELECT demographic_id FROM Demographic WHERE demographic_name = ?
`

func (q *Queries) GetDemographicByName(ctx context.Context, demographicName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getDemographicByName, demographicName)
	var demographic_id int64
	err := row.Scan(&demographic_id)
	return demographic_id, err
}

const getGenreByName = `-- name: GetGenreByName :one
SELECT genre_id FROM Genre WHERE genre_name = ?
`

func (q *Queries) GetGenreByName(ctx context.Context, genreName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getGenreByName, genreName)
	var genre_id int64
	err := row.Scan(&genre_id)
	return genre_id, err
}

const getMangaIDByTitle = `-- name: GetMangaIDByTitle :one
SELECT manga_id FROM Manga WHERE title = ?
`

func (q *Queries) GetMangaIDByTitle(ctx context.Context, title string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMangaIDByTitle, title)
	var manga_id int64
	err := row.Scan(&manga_id)
	return manga_id, err
}

const getSerializationByName = `-- name: GetSerializationByName :one
SELECT serialization_id FROM Serialization WHERE serialization_name = ?
`

func (q *Queries) GetSerializationByName(ctx context.Context, serializationName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getSerializationByName, serializationName)
	var serialization_id int64
	err := row.Scan(&serialization_id)
	return serialization_id, err
}

const getThemeByName = `-- name: GetThemeByName :one
SELECT theme_id FROM Theme WHERE theme_name = ?
`

func (q *Queries) GetThemeByName(ctx context.Context, themeName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getThemeByName, themeName)
	var theme_id int64
	err := row.Scan(&theme_id)
	return theme_id, err
}

const insertAuthor = `-- name: InsertAuthor :one
INSERT INTO Author (author_name) VALUES (?)
RETURNING author_id
`

func (q *Queries) InsertAuthor(ctx context.Context, authorName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertAuthor, authorName)
	var author_id int64
	err := row.Scan(&author_id)
	return author_id, err
}

const insertDemographic = `-- name: InsertDemographic :one
INSERT INTO Demographic (demographic_name) VALUES (?)
RETURNING demographic_id
`

func (q *Queries) InsertDemographic(ctx context.Context, demographicName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertDemographic, demographicName)
	var demographic_id int64
	err := row.Scan(&demographic_id)
	return demographic_id, err
}

const insertGenre = `-- name: InsertGenre :one
INSERT INTO Genre (genre_name) VALUES (?)
RETURNING genre_id
`

func (q *Queries) InsertGenre(ctx context.Context, genreName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertGenre, genreName)
	var genre_id int64
	err := row.Scan(&genre_id)
	return genre_id, err
}

const insertManga = `-- name: InsertManga :one
INSERT INTO Manga (
    title, subtitle, synopsis, score, members, cover_image_path,
    publication_year, type, status, total_volumes, total_chapters
) VALUES (
    ?, ?, ?, ?, ?, ?,
    ?, ?, ?, ?, ?
)
RETURNING manga_id
`

type InsertMangaParams struct {
	Title           string  `json:"title"`
	Subtitle        *string `json:"subtitle"`
	Synopsis        string  `json:"synopsis"`
	Score           float64 `json:"score"`
	Members         int64   `json:"members"`
	CoverImagePath  string  `json:"cover_image_path"`
	PublicationYear int64   `json:"publication_year"`
	Type            string  `json:"type"`
	Status          string  `json:"status"`
	TotalVolumes    *int64  `json:"total_volumes"`
	TotalChapters   *int64  `json:"total_chapters"`
}

func (q *Queries) InsertManga(ctx context.Context, arg InsertMangaParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertManga,
		arg.Title,
		arg.Subtitle,
		arg.Synopsis,
		arg.Score,
		arg.Members,
		arg.CoverImagePath,
		arg.PublicationYear,
		arg.Type,
		arg.Status,
		arg.TotalVolumes,
		arg.TotalChapters,
	)
	var manga_id int64
	err := row.Scan(&manga_id)
	return manga_id, err
}

const insertMangaAuthor = `-- name: InsertMangaAuthor :exec
INSERT OR IGNORE INTO MangaAuthor (manga_id, author_id) VALUES (?, ?)
`

type InsertMangaAuthorParams struct {
	MangaID  int64 `json:"manga_id"`
	AuthorID int64 `json:"author_id"`
}

func (q *Queries) InsertMangaAuthor(ctx context.Context, arg InsertMangaAuthorParams) error {
	_, err := q.db.ExecContext(ctx, insertMangaAuthor, arg.MangaID, arg.AuthorID)
	return err
}

const insertMangaDemographic = `-- name: InsertMangaDemographic :exec
INSERT OR IGNORE INTO MangaDemographic (manga_id, demographic_id) VALUES (?, ?)
`

type InsertMangaDemographicParams struct {
	MangaID       int64 `json:"manga_id"`
	DemographicID int64 `json:"demographic_id"`
}

func (q *Queries) InsertMangaDemographic(ctx context.Context, arg InsertMangaDemographicParams) error {
	_, err := q.db.ExecContext(ctx, insertMangaDemographic, arg.MangaID, arg.DemographicID)
	return err
}

const insertMangaGenre = `-- name: InsertMangaGenre :exec
INSERT OR IGNORE INTO MangaGenre (manga_id, genre_id) VALUES (?, ?)
`

type InsertMangaGenreParams struct {
	MangaID int64 `json:"manga_id"`
	GenreID int64 `json:"genre_id"`
}

func (q *Queries) InsertMangaGenre(ctx context.Context, arg InsertMangaGenreParams) error {
	_, err := q.db.ExecContext(ctx, insertMangaGenre, arg.MangaID, arg.GenreID)
	return err
}

const insertMangaSerialization = `-- name: InsertMangaSerialization :exec
INSERT OR IGNORE INTO MangaSerialization (manga_id, serialization_id) VALUES (?, ?)
`

type InsertMangaSerializationParams struct {
	MangaID         int64 `json:"manga_id"`
	SerializationID int64 `json:"serialization_id"`
}

func (q *Queries) InsertMangaSerialization(ctx context.Context, arg InsertMangaSerializationParams) error {
	_, err := q.db.ExecContext(ctx, insertMangaSerialization, arg.MangaID, arg.SerializationID)
	return err
}

const insertMangaTheme = `-- name: InsertMangaTheme :exec
INSERT OR IGNORE INTO MangaTheme (manga_id, theme_id) VALUES (?, ?)
`

type InsertMangaThemeParams struct {
	MangaID int64 `json:"manga_id"`
	ThemeID int64 `json:"theme_id"`
}

func (q *Queries) InsertMangaTheme(ctx context.Context, arg InsertMangaThemeParams) error {
	_, err := q.db.ExecContext(ctx, insertMangaTheme, arg.MangaID, arg.ThemeID)
	return err
}

const insertSerialization = `-- name: InsertSerialization :one
INSERT INTO Serialization (serialization_name) VALUES (?)
RETURNING serialization_id
`

func (q *Queries) InsertSerialization(ctx context.Context, serializationName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertSerialization, serializationName)
	var serialization_id int64
	err := row.Scan(&serialization_id)
	return serialization_id, err
}

const insertTheme = `-- name: InsertTheme :one
INSERT INTO Theme (theme_name) VALUES (?)
RETURNING theme_id
`

func (q *Queries) InsertTheme(ctx context.Context, themeName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertTheme, themeName)
	var theme_id int64
	err := row.Scan(&theme_id)
	return theme_id, err
}

const searchMangaByTitle = `-- name: SearchMangaByTitle :many
SELECT
    manga_id,
    title,
    subtitle,
    score,
    status
FROM
    Manga
WHERE
    title LIKE ?
ORDER BY title
LIMIT ?
`

type SearchMangaByTitleParams struct {
	Title string `json:"title"`
	Limit int64  `json:"limit"`
}

type SearchMangaByTitleRow struct {
	MangaID  int64   `json:"manga_id"`
	Title    string  `json:"title"`
	Subtitle *string `json:"subtitle"`
	Score    float64 `json:"score"`
	Status   string  `json:"status"`
}

// Example Query: Search Manga by Title Keyword
func (q *Queries) SearchMangaByTitle(ctx context.Context, arg SearchMangaByTitleParams) ([]SearchMangaByTitleRow, error) {
	rows, err := q.db.QueryContext(ctx, searchMangaByTitle, arg.Title, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchMangaByTitleRow
	for rows.Next() {
		var i SearchMangaByTitleRow
		if err := rows.Scan(
			&i.MangaID,
			&i.Title,
			&i.Subtitle,
			&i.Score,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
