// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package mangadb

import (
	"context"
	"database/sql"
)

const filterMangaByGenre = `-- name: FilterMangaByGenre :many
SELECT
    m.manga_id,
    m.title,
    m.subtitle,
    m.score,
    m.status
FROM
    Manga m
JOIN MangaGenre mg ON m.manga_id = mg.manga_id
JOIN Genre g ON mg.genre_id = g.genre_id
WHERE
    g.genre_name = ?
ORDER BY m.title
LIMIT ?
`

type FilterMangaByGenreParams struct {
	GenreName string
	Limit     int64
}

type FilterMangaByGenreRow struct {
	MangaID  int64
	Title    string
	Subtitle sql.NullString
	Score    sql.NullFloat64
	Status   sql.NullString
}

// Example Query: Filter Manga by Genre
func (q *Queries) FilterMangaByGenre(ctx context.Context, arg FilterMangaByGenreParams) ([]FilterMangaByGenreRow, error) {
	rows, err := q.db.QueryContext(ctx, filterMangaByGenre, arg.GenreName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterMangaByGenreRow
	for rows.Next() {
		var i FilterMangaByGenreRow
		if err := rows.Scan(
			&i.MangaID,
			&i.Title,
			&i.Subtitle,
			&i.Score,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthorByName = `-- name: GetAuthorByName :one
SELECT author_id FROM Author WHERE author_name = ?
`

func (q *Queries) GetAuthorByName(ctx context.Context, authorName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAuthorByName, authorName)
	var author_id int64
	err := row.Scan(&author_id)
	return author_id, err
}

const getDemographicByName = `-- name: GetDemographicByName :one
SELECT demographic_id FROM Demographic WHERE demographic_name = ?
`

func (q *Queries) GetDemographicByName(ctx context.Context, demographicName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getDemographicByName, demographicName)
	var demographic_id int64
	err := row.Scan(&demographic_id)
	return demographic_id, err
}

const getGenreByName = `-- name: GetGenreByName :one
SELECT genre_id FROM Genre WHERE genre_name = ?
`

func (q *Queries) GetGenreByName(ctx context.Context, genreName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getGenreByName, genreName)
	var genre_id int64
	err := row.Scan(&genre_id)
	return genre_id, err
}

const getMangaDetails = `-- name: GetMangaDetails :many
SELECT
    m.manga_id,
    m.title,
    m.subtitle,
    m.synopsis,
    m.score,
    m.members,
    m.cover_image_path,
    m.publication_year,
    m.type,
    m.status,
    m.total_volumes,
    m.total_chapters,
    GROUP_CONCAT(DISTINCT g.genre_name) AS genres,
    GROUP_CONCAT(DISTINCT a.author_name || ' (' || ma.role || ')') AS authors,
    GROUP_CONCAT(DISTINCT s.serialization_name) AS serializations,
    GROUP_CONCAT(DISTINCT d.demographic_name) AS demographics,
    GROUP_CONCAT(DISTINCT t.theme_name) AS themes
FROM
    Manga m
LEFT JOIN MangaGenre mg ON m.manga_id = mg.manga_id
LEFT JOIN Genre g ON mg.genre_id = g.genre_id
LEFT JOIN MangaAuthor ma ON m.manga_id = ma.manga_id
LEFT JOIN Author a ON ma.author_id = a.author_id
LEFT JOIN MangaSerialization ms ON m.manga_id = ms.manga_id
LEFT JOIN Serialization s ON ms.serialization_id = s.serialization_id
LEFT JOIN MangaDemographic md ON m.manga_id = md.manga_id
LEFT JOIN Demographic d ON md.demographic_id = d.demographic_id
LEFT JOIN MangaTheme mt ON m.manga_id = mt.manga_id
LEFT JOIN Theme t ON mt.theme_id = t.theme_id
WHERE m.manga_id = ? OR ? IS NULL -- Allows fetching a specific manga or all if NULL is passed
GROUP BY m.manga_id
ORDER BY m.title
`

type GetMangaDetailsParams struct {
	MangaID int64
	Column2 interface{}
}

type GetMangaDetailsRow struct {
	MangaID         int64
	Title           string
	Subtitle        sql.NullString
	Synopsis        sql.NullString
	Score           sql.NullFloat64
	Members         sql.NullInt64
	CoverImagePath  sql.NullString
	PublicationYear sql.NullInt64
	Type            sql.NullString
	Status          sql.NullString
	TotalVolumes    sql.NullInt64
	TotalChapters   sql.NullInt64
	Genres          string
	Authors         string
	Serializations  string
	Demographics    string
	Themes          string
}

// Example Query: Get all Manga with their Genres, Authors, etc.
// This is a more complex join, demonstrating how to retrieve related data.
func (q *Queries) GetMangaDetails(ctx context.Context, arg GetMangaDetailsParams) ([]GetMangaDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMangaDetails, arg.MangaID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMangaDetailsRow
	for rows.Next() {
		var i GetMangaDetailsRow
		if err := rows.Scan(
			&i.MangaID,
			&i.Title,
			&i.Subtitle,
			&i.Synopsis,
			&i.Score,
			&i.Members,
			&i.CoverImagePath,
			&i.PublicationYear,
			&i.Type,
			&i.Status,
			&i.TotalVolumes,
			&i.TotalChapters,
			&i.Genres,
			&i.Authors,
			&i.Serializations,
			&i.Demographics,
			&i.Themes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMangaIDByTitle = `-- name: GetMangaIDByTitle :one
SELECT manga_id FROM Manga WHERE title = ?
`

func (q *Queries) GetMangaIDByTitle(ctx context.Context, title string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMangaIDByTitle, title)
	var manga_id int64
	err := row.Scan(&manga_id)
	return manga_id, err
}

const getSerializationByName = `-- name: GetSerializationByName :one
SELECT serialization_id FROM Serialization WHERE serialization_name = ?
`

func (q *Queries) GetSerializationByName(ctx context.Context, serializationName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getSerializationByName, serializationName)
	var serialization_id int64
	err := row.Scan(&serialization_id)
	return serialization_id, err
}

const getThemeByName = `-- name: GetThemeByName :one
SELECT theme_id FROM Theme WHERE theme_name = ?
`

func (q *Queries) GetThemeByName(ctx context.Context, themeName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getThemeByName, themeName)
	var theme_id int64
	err := row.Scan(&theme_id)
	return theme_id, err
}

const insertAuthor = `-- name: InsertAuthor :one
INSERT INTO Author (author_name) VALUES (?)
RETURNING author_id
`

func (q *Queries) InsertAuthor(ctx context.Context, authorName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertAuthor, authorName)
	var author_id int64
	err := row.Scan(&author_id)
	return author_id, err
}

const insertDemographic = `-- name: InsertDemographic :one
INSERT INTO Demographic (demographic_name) VALUES (?)
RETURNING demographic_id
`

func (q *Queries) InsertDemographic(ctx context.Context, demographicName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertDemographic, demographicName)
	var demographic_id int64
	err := row.Scan(&demographic_id)
	return demographic_id, err
}

const insertGenre = `-- name: InsertGenre :one
INSERT INTO Genre (genre_name) VALUES (?)
RETURNING genre_id
`

func (q *Queries) InsertGenre(ctx context.Context, genreName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertGenre, genreName)
	var genre_id int64
	err := row.Scan(&genre_id)
	return genre_id, err
}

const insertManga = `-- name: InsertManga :execrows
INSERT INTO Manga (
    title, subtitle, synopsis, score, members, cover_image_path,
    publication_year, type, status, total_volumes, total_chapters
) VALUES (
    ?, ?, ?, ?, ?, ?,
    ?, ?, ?, ?, ?
)
`

type InsertMangaParams struct {
	Title           string
	Subtitle        sql.NullString
	Synopsis        sql.NullString
	Score           sql.NullFloat64
	Members         sql.NullInt64
	CoverImagePath  sql.NullString
	PublicationYear sql.NullInt64
	Type            sql.NullString
	Status          sql.NullString
	TotalVolumes    sql.NullInt64
	TotalChapters   sql.NullInt64
}

func (q *Queries) InsertManga(ctx context.Context, arg InsertMangaParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertManga,
		arg.Title,
		arg.Subtitle,
		arg.Synopsis,
		arg.Score,
		arg.Members,
		arg.CoverImagePath,
		arg.PublicationYear,
		arg.Type,
		arg.Status,
		arg.TotalVolumes,
		arg.TotalChapters,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const insertMangaAuthor = `-- name: InsertMangaAuthor :exec
INSERT OR IGNORE INTO MangaAuthor (manga_id, author_id, role) VALUES (?, ?, ?)
`

type InsertMangaAuthorParams struct {
	MangaID  int64
	AuthorID int64
	Role     sql.NullString
}

func (q *Queries) InsertMangaAuthor(ctx context.Context, arg InsertMangaAuthorParams) error {
	_, err := q.db.ExecContext(ctx, insertMangaAuthor, arg.MangaID, arg.AuthorID, arg.Role)
	return err
}

const insertMangaDemographic = `-- name: InsertMangaDemographic :exec
INSERT OR IGNORE INTO MangaDemographic (manga_id, demographic_id) VALUES (?, ?)
`

type InsertMangaDemographicParams struct {
	MangaID       int64
	DemographicID int64
}

func (q *Queries) InsertMangaDemographic(ctx context.Context, arg InsertMangaDemographicParams) error {
	_, err := q.db.ExecContext(ctx, insertMangaDemographic, arg.MangaID, arg.DemographicID)
	return err
}

const insertMangaGenre = `-- name: InsertMangaGenre :exec
INSERT OR IGNORE INTO MangaGenre (manga_id, genre_id) VALUES (?, ?)
`

type InsertMangaGenreParams struct {
	MangaID int64
	GenreID int64
}

func (q *Queries) InsertMangaGenre(ctx context.Context, arg InsertMangaGenreParams) error {
	_, err := q.db.ExecContext(ctx, insertMangaGenre, arg.MangaID, arg.GenreID)
	return err
}

const insertMangaSerialization = `-- name: InsertMangaSerialization :exec
INSERT OR IGNORE INTO MangaSerialization (manga_id, serialization_id) VALUES (?, ?)
`

type InsertMangaSerializationParams struct {
	MangaID         int64
	SerializationID int64
}

func (q *Queries) InsertMangaSerialization(ctx context.Context, arg InsertMangaSerializationParams) error {
	_, err := q.db.ExecContext(ctx, insertMangaSerialization, arg.MangaID, arg.SerializationID)
	return err
}

const insertMangaTheme = `-- name: InsertMangaTheme :exec
INSERT OR IGNORE INTO MangaTheme (manga_id, theme_id) VALUES (?, ?)
`

type InsertMangaThemeParams struct {
	MangaID int64
	ThemeID int64
}

func (q *Queries) InsertMangaTheme(ctx context.Context, arg InsertMangaThemeParams) error {
	_, err := q.db.ExecContext(ctx, insertMangaTheme, arg.MangaID, arg.ThemeID)
	return err
}

const insertSerialization = `-- name: InsertSerialization :one
INSERT INTO Serialization (serialization_name) VALUES (?)
RETURNING serialization_id
`

func (q *Queries) InsertSerialization(ctx context.Context, serializationName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertSerialization, serializationName)
	var serialization_id int64
	err := row.Scan(&serialization_id)
	return serialization_id, err
}

const insertTheme = `-- name: InsertTheme :one
INSERT INTO Theme (theme_name) VALUES (?)
RETURNING theme_id
`

func (q *Queries) InsertTheme(ctx context.Context, themeName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertTheme, themeName)
	var theme_id int64
	err := row.Scan(&theme_id)
	return theme_id, err
}

const searchMangaByTitle = `-- name: SearchMangaByTitle :many
SELECT
    manga_id,
    title,
    subtitle,
    score,
    status
FROM
    Manga
WHERE
    title LIKE ?
ORDER BY title
LIMIT ?
`

type SearchMangaByTitleParams struct {
	Title string
	Limit int64
}

type SearchMangaByTitleRow struct {
	MangaID  int64
	Title    string
	Subtitle sql.NullString
	Score    sql.NullFloat64
	Status   sql.NullString
}

// Example Query: Search Manga by Title Keyword
func (q *Queries) SearchMangaByTitle(ctx context.Context, arg SearchMangaByTitleParams) ([]SearchMangaByTitleRow, error) {
	rows, err := q.db.QueryContext(ctx, searchMangaByTitle, arg.Title, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchMangaByTitleRow
	for rows.Next() {
		var i SearchMangaByTitleRow
		if err := rows.Scan(
			&i.MangaID,
			&i.Title,
			&i.Subtitle,
			&i.Score,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
